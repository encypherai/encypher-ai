# OpenAI Integration

This guide explains how to integrate Encypher with the OpenAI API to embed and verify metadata in content generated by models like GPT-4.

## Prerequisites

Before you begin, ensure you have an OpenAI API key and have installed the required packages:

```bash
uv add encypher-ai openai
```

## Best Practices

1.  **Include Model Information**: Record the model name/version in `custom_metadata` for traceability.
2.  **Timestamps (optional)**: Timestamps are recommended but optional across all formats (including C2PA). When omitted, C2PA assertions that normally include a `when` field will simply omit it.
3.  **Secure Keys**: Manage private keys securely and use a `public_key_resolver` that resolves `signer_id` to public keys.

## Non-Streaming Example

This example demonstrates how to sign and verify a standard, non-streaming response from the OpenAI API.

```python
import os
import openai

from encypher.core.keys import generate_ed25519_key_pair
from encypher.core.unicode_metadata import UnicodeMetadata

# --- 1. Setup ---
# In a real application, use a secure key management solution.
# Make sure your OPENAI_API_KEY is set as an environment variable.

private_key, public_key = generate_ed25519_key_pair()
signer_id = "openai-guide-signer-001"
public_keys_store = {signer_id: public_key}

client = openai.OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

# --- 2. Call the OpenAI API ---
response = client.chat.completions.create(
    model="gpt-4o",
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Explain the significance of the C2PA standard."}
    ]
)
original_text = response.choices[0].message.content

# --- 3. Embed Metadata ---
custom_metadata = {
    "openai_model": response.model,
    "usage_tokens": dict(response.usage),
}

encoded_text = UnicodeMetadata.embed_metadata(
    text=original_text,
    private_key=private_key,
    signer_id=signer_id,
    custom_metadata=custom_metadata,
)

print("--- Response with Embedded Metadata ---")
print(encoded_text)

# --- 4. Verify Metadata ---
is_valid, extracted_signer_id, payload = UnicodeMetadata.verify_metadata(
    text=encoded_text,
    public_key_resolver=public_keys_store.get,
)

print(f"\nSignature valid: {is_valid}")
if is_valid and payload:
    print(f"Verified Signer ID: {extracted_signer_id}")
    print(f"Verified Payload: {payload}")
```

## Streaming Example

For streaming responses, use the `StreamingHandler` class to buffer chunks and embed the payload efficiently.

```python
import os
import openai
from encypher.streaming.handlers import StreamingHandler
from encypher.core.keys import generate_ed25519_key_pair
from encypher.core.unicode_metadata import UnicodeMetadata

# --- 1. Setup ---
private_key, public_key = generate_ed25519_key_pair()
signer_id = "openai-streaming-signer-001"
public_keys_store = {signer_id: public_key}

client = openai.OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

# --- 2. Initialize the StreamingHandler ---
streaming_handler = StreamingHandler(
    private_key=private_key,
    signer_id=signer_id,
    timestamp=None,
    custom_metadata={"openai_model": "gpt-4o-stream"},
    encode_first_chunk_only=True,
    metadata_format="basic",
)

# --- 3. Process the Stream ---
stream = client.chat.completions.create(
    model="gpt-4o",
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Write a short story about a friendly robot."}
    ],
    stream=True,
)

full_encoded_response = ""
print("--- Streaming Response with Embedded Metadata ---")
for chunk in stream:
    content = chunk.choices[0].delta.content or ""
    encoded_chunk = streaming_handler.process_chunk(chunk=content)
    if encoded_chunk:
        print(encoded_chunk, end="")
        full_encoded_response += encoded_chunk

# --- 4. Finalize the Stream ---
final_chunk = streaming_handler.finalize()
if final_chunk:
    print(final_chunk, end="")
    full_encoded_response += final_chunk
print("\n--- End of Stream ---")

# --- 5. Verify the Complete Streamed Text ---
is_valid, extracted_signer_id, payload = UnicodeMetadata.verify_metadata(
    text=full_encoded_response,
    public_key_resolver=public_keys_store.get,
    require_hard_binding=False,
)

print(f"\nSignature valid: {is_valid}")
if is_valid and payload:
    print(f"Verified Signer ID: {extracted_signer_id}")
    print(f"Verified Payload: {payload}")
```
